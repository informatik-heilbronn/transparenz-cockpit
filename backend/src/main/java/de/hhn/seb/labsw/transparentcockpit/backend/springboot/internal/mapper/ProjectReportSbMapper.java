package de.hhn.seb.labsw.transparentcockpit.backend.springboot.internal.mapper;

import de.hhn.seb.labsw.transparentcockpit.backend.models.project.base.group.Group;
import de.hhn.seb.labsw.transparentcockpit.backend.models.project.base.input.DataType;
import de.hhn.seb.labsw.transparentcockpit.backend.models.project.base.input.InputModifier;
import de.hhn.seb.labsw.transparentcockpit.backend.models.project.base.input.InputType;
import de.hhn.seb.labsw.transparentcockpit.backend.models.project.report.ProjectReport;
import de.hhn.seb.labsw.transparentcockpit.backend.models.project.report.input.MultiInput;
import de.hhn.seb.labsw.transparentcockpit.backend.models.project.report.input.SelectMultiInput;
import de.hhn.seb.labsw.transparentcockpit.backend.models.project.report.input.SelectSingleInput;
import de.hhn.seb.labsw.transparentcockpit.backend.models.project.report.input.SingleInput;
import de.hhn.seb.labsw.transparentcockpit.backend.springboot.internal.models.project.report.ProjectReportSb;

import java.util.*;

/**
 * ProjectReport SpringBoot Mapper.
 */
public class ProjectReportSbMapper {


    public static ProjectReport toProjectReport(Map<String, Object> input, String projectReportId) {
        if (input.size() != 2) {
            throw new IllegalArgumentException("Too much or too little Field found in Input expected '2'");
        }

        ProjectReport projectReport = new ProjectReport(UUID.fromString(input.get("templateId").toString()));

        LinkedHashMap<String, Object> castedInputGroups = (LinkedHashMap<String, Object>) input.get("groups");
        for (Map.Entry<String, Object> inputGroupEntry : castedInputGroups.entrySet()) {
            LinkedHashMap<String, Object> castedInputGroup = (LinkedHashMap<String, Object>) inputGroupEntry.getValue();

            if (castedInputGroup.size() != 3) {
                throw new IllegalArgumentException("Too much or too little Field found in Group '" + inputGroupEntry.getKey()
                        + "' expected '3'");
            }

            Group group = new Group(castedInputGroup.get("letter").toString(), castedInputGroup.get("name").toString());

            LinkedHashMap<String, Object> castedInputFields = (LinkedHashMap<String, Object>) castedInputGroup.get("fields");
            for (Map.Entry<String, Object> castedInputFieldEntry : castedInputFields.entrySet()) {
                LinkedHashMap<String, Object> castedInputField =
                        (LinkedHashMap<String, Object>) castedInputFieldEntry.getValue();

                if (!(castedInputField.size() == 6 | castedInputField.size() == 5)) {
                    throw new IllegalArgumentException("Too much or too little Field found in Field '"
                            + inputGroupEntry.getKey() + "." + castedInputFieldEntry.getKey() + "' expected '5' or '6'");
                }

                ArrayList<String> modifierList = (ArrayList<String>) castedInputField.get("modifiers");
                Set<InputModifier> modifiers = new HashSet<>();
                for (String modifier : modifierList) {
                    modifiers.add(InputModifier.valueOf(modifier));
                }

                DataType dataType = DataType.valueOf(castedInputField.get("type").toString());

                InputType type = InputType.valueOf(castedInputField.get("inputType").toString());
                if (type == InputType.SINGLE_INPUT) {
                    Object castedValue = castedInputField.getOrDefault("value", null);
                    if (castedValue instanceof List | castedValue instanceof Map) {
                        throw new IllegalArgumentException("'" + inputGroupEntry.getKey() + "." + castedInputFieldEntry.getKey()
                                + ".value' can not be an List or Map");
                    }

                    SingleInput singleInput;
                    if (modifiers.contains(InputModifier.AUTOGENERATED) && modifiers.contains(InputModifier.PROJECT_ID)) {
                        singleInput = new SingleInput(castedInputField.get("number").toString(),
                                castedInputField.get("name").toString(), modifiers, dataType, projectReportId);
                    } else {
                        singleInput = new SingleInput(castedInputField.get("number").toString(),
                                castedInputField.get("name").toString(), modifiers, dataType,
                                ValueSbMapper.castValue(dataType, castedInputField.getOrDefault("value", null)));
                    }

                    group.addField(singleInput);
                } else if (type == InputType.MULTI_INPUT) {
                    MultiInput multiInput = new MultiInput(castedInputField.get("number").toString(),
                            castedInputField.get("name").toString(), modifiers, dataType, new ArrayList<>());

                    ArrayList<Object> castedInputValues = (ArrayList<Object>) castedInputField.getOrDefault("values",
                            new ArrayList<>());
                    for (Object inputValue : castedInputValues) {
                        if (inputValue instanceof List | inputValue instanceof Map) {
                            throw new IllegalArgumentException("'" + inputGroupEntry.getKey() + "." + castedInputFieldEntry.getKey()
                                    + ".values' can not be an List or Map");
                        }

                        multiInput.addValues(ValueSbMapper.castValue(dataType, inputValue));
                    }

                    group.addField(multiInput);
                } else if (type == InputType.SELECT_SINGLE_INPUT) {
                    Object castedValue = castedInputField.getOrDefault("value", null);
                    if (castedValue instanceof List | castedValue instanceof Map) {
                        throw new IllegalArgumentException("'" + inputGroupEntry.getKey() + "." + castedInputFieldEntry.getKey()
                                + ".value' can not be an List or Map");
                    }

                    SelectSingleInput selectSingleInput = new SelectSingleInput(castedInputField.get("number").toString(),
                            castedInputField.get("name").toString(), modifiers, dataType, new ArrayList<>(),
                            ValueSbMapper.castValue(dataType, castedValue));

                    group.addField(selectSingleInput);
                } else if (type == InputType.SELECT_MULTI_INPUT) {
                    SelectMultiInput selectMultiInput = new SelectMultiInput(castedInputField.get("number").toString(),
                            castedInputField.get("name").toString(), modifiers, dataType, new ArrayList<>(), new ArrayList<>());

                    ArrayList<Object> castedInputValues = (ArrayList<Object>) castedInputField.getOrDefault("values",
                            new ArrayList<>());
                    for (Object inputValue : castedInputValues) {
                        if (inputValue instanceof List | inputValue instanceof Map) {
                            throw new IllegalArgumentException("'" + inputGroupEntry.getKey() + "." + castedInputFieldEntry.getKey()
                                    + ".values' can not be an List or Map");
                        }

                        selectMultiInput.addValue(ValueSbMapper.castValue(dataType, inputValue));
                    }

                    group.addField(selectMultiInput);

                }
            }
            projectReport.addGroup(group);
        }

        return projectReport;
    }

    public static ProjectReportSb convertToSb(ProjectReport projectReport) {
        ProjectReportSb convertedProjectReport = new ProjectReportSb(projectReport.getProjectNumber(),
                projectReport.getName(), projectReport.getGroup(), projectReport.getTemplateId());

        for (Map.Entry<String, Group> groupEntry : projectReport.getGroups().entrySet()) {
            convertedProjectReport.addGroup(groupEntry.getValue());
        }

        return convertedProjectReport;
    }

}
