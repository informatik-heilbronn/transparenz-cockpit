package de.hhn.seb.labsw.transparentcockpit.backend.models.project.util;

import de.hhn.seb.labsw.transparentcockpit.backend.exceptions.validation.ModifierException;
import de.hhn.seb.labsw.transparentcockpit.backend.exceptions.validation.ValueException;
import de.hhn.seb.labsw.transparentcockpit.backend.models.project.base.input.BaseInput;

import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Objects;
import java.util.Set;

/**
 * Validation Util.
 * Helps Validation ProjectReport Inputs
 */
public class ValidationUtil {

    /**
     * Validates if All given Modifier are allowed.
     *
     * @param className        ClassName (for Logging Purposes)
     * @param actualModifiers  given Modifier
     * @param allowedModifiers allowed Modifier
     * @throws ModifierException If Modifiers are not allowed
     */
    public static void validateModifier(String className,
                                        Set<InputModifier> actualModifiers,
                                        InputModifier... allowedModifiers) throws ModifierException {

        for (InputModifier inputModifier : actualModifiers) {
            switch (inputModifier) {
                case AUTOGENERATED:
                    if (!Arrays.asList(allowedModifiers).contains(InputModifier.AUTOGENERATED)) {
                        throw new ModifierException(className + " can not be Autogenerated", InputModifier.AUTOGENERATED);
                    }
                    break;
                case REQUIRED:
                    if (!Arrays.asList(allowedModifiers).contains(InputModifier.REQUIRED)) {
                        throw new ModifierException(className + " can not be Required", InputModifier.REQUIRED);
                    }
                    break;
                case DOUBLE_VALUE_ALLOWED:
                    if (!Arrays.asList(allowedModifiers).contains(InputModifier.DOUBLE_VALUE_ALLOWED)) {
                        throw new ModifierException(className + " can not be Autogenerated", InputModifier.DOUBLE_VALUE_ALLOWED);
                    }
                    break;
                case PROJECT_ID:
                    if (!Arrays.asList(allowedModifiers).contains(InputModifier.PROJECT_ID)) {
                        throw new ModifierException(className + " can not be Project Id", InputModifier.PROJECT_ID);
                    }
                    break;
                case PROJECT_NAME:
                    if (!Arrays.asList(allowedModifiers).contains(InputModifier.PROJECT_NAME)) {
                        throw new ModifierException(className + " can not be Project Name", InputModifier.PROJECT_NAME);
                    }
                    break;
                default:
                    break;
            }
        }
    }


    public static void validateFields(BaseInput template,
                                      BaseInput input) throws IllegalArgumentException {
        if (!Objects.equals(template.getNumber(), input.getNumber())) {
            throw new IllegalArgumentException("TemplateInput and Input dont match."
                    + "\n Gotten Number " + template.getNumber() + " but expected " + template.getNumber());
        }

        if (!Objects.equals(template.getName(), input.getName())) {
            throw new IllegalArgumentException("TemplateInput and Input dont match."
                    + "\n Gotten Name " + template.getName() + " but expected " + template.getName());
        }

        if (!Objects.equals(template.getType(), input.getType())) {
            throw new IllegalArgumentException("TemplateInput and Input dont match."
                    + "\n Gotten Type " + template.getType() + " but expected " + template.getType());
        }
    }

    /**
     * Validates the Allowed Values.
     *
     * @param values list of the allowed Values
     * @throws ValueException if a double Value has been found
     */
    public static void validateAllowedValues(List<Object> values) throws ValueException {
        HashSet<Object> checkSet = new HashSet<>();

        for (Object object : values) {
            if (!checkSet.contains(object)) {
                checkSet.add(object);
            } else {
                throw new ValueException("Found double AllowedValue but is not allowed");
            }
        }
    }

    /**
     * Validates the Values.
     *
     * @param modifiers list of the Modifiers
     * @param values    list of the Values
     * @throws ValueException if double Value has been found but not allowed
     */
    public static void validateValues(Set<InputModifier> modifiers,
                                      List<Object> values) throws ValueException {
        if (!modifiers.contains(InputModifier.DOUBLE_VALUE_ALLOWED)) {
            HashSet<Object> checkSet = new HashSet<>();

            for (Object object : values) {
                if (!checkSet.contains(object)) {
                    checkSet.add(object);
                } else {
                    throw new ValueException("Found double Value but is not allowed");
                }
            }
        }
    }

    /**
     * Validates the Values.
     *
     * @param modifiers     list of the Modifiers
     * @param allowedValues list of the AllowedValues
     * @param values        list of the Values
     * @throws ValueException if double Value has been found but not allowed or
     *                        if values contains Value which is not in AllowedValues
     */
    public static void validateValues(Set<InputModifier> modifiers,
                                      List<Object> allowedValues,
                                      List<Object> values) throws ValueException {
        validateValues(modifiers, values);

        for (Object object : values) {
            if (object != null && !allowedValues.contains(object.toString())) {
                throw new ValueException("Found new Value but is not allowed");
            }
        }
    }
}
